# FAQ

## About Engine

### How are Engine and the thirdweb Contract SDK different?

Engine is a server that manages your backend wallets and how they interact with contracts. This difference unlocks capabilities that thirdweb and other web3 SDKs, including:

- Management of KMS backend wallets
- Fine-grained access control with access tokens
- Transaction parallelization to handle higher throughput per wallet
- Observability and retries on stuck transactions
- Webhooks on completed transactions to sync onchain and off-chain activity

Additionally, Engine is built on top of the thirdweb SDK and has the same capabilities.

### Does Engine work with all thirdweb smart contracts?

Yes. Engine has intuitive interfaces to deploy prebuilt contracts, manage smart accounts, run a marketplace, and more.

### Does Engine work with my non-thirdweb smart contract?

Yes. Engine can read and write to any EVM contract with low-level API calls, including providing raw calldata. ERC-721 and ERC-1155 APIs can also be used for [contracts imported to thirdweb](https://support.thirdweb.com/smart-contracts/rtHYyzspnPaHmmANmJQz1k/importing-non-thirdweb-contracts-into-the-dashboard/hELLjgTc8TWrMdMEQkm2Es).

## Using Engine

### How do I wait for a transaction to be mined?

Write calls to contracts do not block until they are mined. Instead they enqueue an async job and immediately return a reference to the job called `queueId`.

Here are three ways to determine when the job is mined:

- Use [webhooks](/engine/features/webhooks) to notify your backend when a transaction event occurs.
- Poll the `/transaction/status/<queue_id>` endpoint.
- Use websockets:

  ```js
  const socket = new WebSocket(
  	"wss://<engine_url>/transaction/status/<queue_id>?token=<session_token>",
  );
  socket.onmessage = (event) => {
  	const res = JSON.parse(event.data);
  	console.log("Received data:", JSON.parse(res.result));
  };
  ```

### How do I customize my RPC?

Use [Update Chain Configuration](https://redocly.github.io/redoc/?url=https://demo.web3api.thirdweb.com/json#tag/Configuration/operation/updateChainsConfiguration) to override a chain's settings.

Here's an example snippet to provide your own RPC on Polygon.

Endpoint

```text
POST /configuration/chains
```

Headers

```text
Content-Type: application/json
Authorization: Bearer <access_token>
```

Body

```json
[
	{
		"name": "Polygon Mainnet",
		"chain": "Polygon",
		"slug": "polygon",
		"chainId": 137,
		"rpc": ["https://<custom_rpc_url>"],
		"nativeCurrency": {
			"name": "MATIC",
			"symbol": "MATIC",
			"decimals": 18
		}
	}
]
```

### How to manage log output in Engine?

To tailor the verbosity of log messages in Engine, adjust the `LOG_LEVEL` environment variable according to your requirements.
Engine utilizes `Pino` for logging purposes, which categorizes log severity using the following levels, with ascending numerical values denoting greater significance:

- `fatal` (60): Critical errors that cause a program to terminate
- `error` (50): Significant issues that require immediate attention
- `warn`  (40): Warnings that indicate potential problems
- `info`  (30): General informational messages about program operation
- `debug` (20): Detailed information for debugging purposes
- `trace` (10): Very detailed debugging information

By configuring `LOG_LEVEL` to `error`, Engine is set to log only `error` and `fatal` messages, effectively filtering out log entries.

Example:

```
# .env file
LOG_LEVEL="error"
```

### How to prevent `SIGSEGV` errors with the Engine docker image?

To ensure stable operation of the Engine docker image and avoid encountering a `SIGSEGV` (Segmentation Fault) error, it is crucial to allocate sufficient computational resources to your container. Specifically, ensure that at least `0.5 vCPU & 1 GB memory` is dedicated to the container running the docker image. Adequate resource allocation plays a vital role in preventing SIGSEGV errors, which typically arise from issues in memory access or insufficient computational capacity.

### How to mitigate Prisma errors related connections and/or prisma transactions?

To enhance the stability and performance of transactions and database connections when utilizing Engine, it's recommended to explicitly define the `connection_limit` parameter within your `POSTGRES_CONNECTION_URL` environment variable. This adjustment permits Engine to establish up to 10 simultaneous connections to the PostgreSQL database, addressing potential limitations set by Prisma on concurrent connections. Such configuration ensures that Engine can efficiently manage database interactions without encountering connection-related errors.

Example configuration:

```
# .env file
POSTGRES_CONNECTION_URL=postgres://postgres:postgres@localhost:5432/postgres?connection_limit=10
```

## Troubleshooting

### How do I resolve issues connecting to Postgres DB?

Here are some common troubleshooting tips:

- Ensure the Postgres DB is running in Docker:
  - In same container, ensure the `host` in the `POSTGRES_CONNECTION_URL` is set to `localhost`.
  - In different container, ensure the `host` in the `POSTGRES_CONNECTION_URL` is set to `host.docker.internal`.
- Ensure the Postgres DB connection URL and credentials are correct.
- Ensure the database name exists on the Postgres DB.
